# Task CRUD 架构设计

## Context

本次实现是 TaKeKe 项目的第一个业务领域（除认证外），需要建立清晰的 DDD 分层架构模式，为后续领域（focus, rewards, statistics 等）提供参考范例。

### 约束条件
1. 必须遵循项目现有的 DDD 架构模式（参考 auth 领域）
2. 使用 SQLModel 作为 ORM，PostgreSQL 作为数据库
3. 响应格式必须与 auth 领域保持一致
4. 第一阶段聚焦核心 CRUD 功能，避免过度设计

### 利益相关者
- 前端开发团队：需要清晰的 API 文档和统一的响应格式
- 后端开发团队：需要可维护、可扩展的代码架构
- 产品团队：需要快速交付核心任务管理功能

## Goals / Non-Goals

### Goals
1. 实现完整的任务 CRUD 操作，支持基础的任务管理需求
2. 建立清晰的 DDD 分层架构，提供良好的代码组织范例
3. 支持父子任务关系，为任务树结构打下基础
4. 提供完整的单元测试和集成测试（覆盖率 > 95%）
5. 保持简单，遵循 KISS 和 YAGNI 原则

### Non-Goals
1. 不实现任务完成抽奖功能（留待第二阶段）
2. 不实现 Top3 管理功能
3. 不实现高级筛选和全文搜索
4. 不实现任务树的递归查询
5. 不优化性能（第一阶段优先功能完整性）

## Decisions

### 决策 1：数据库设计 - 简化字段集

**选择**：第一阶段只保留 15 个核心字段，不预留番茄钟相关字段。

**理由**：
- YAGNI 原则：暂不需要的字段不添加，等需要时再通过数据库迁移添加
- 减少表字段数量，提升查询性能
- SQLModel 迁移很方便，后续添加字段成本低

**替代方案**：
- 方案 A：预留所有未来可能用到的字段（estimated_pomodoros, actual_pomodoros, completion_percentage 等）
  - 优点：表结构一次到位，避免后续迁移
  - 缺点：增加复杂度，字段无用时浪费存储空间
  - **拒绝原因**：违反 YAGNI 原则

### 决策 2：Tags 存储方式 - JSON 字段

**选择**：tags 使用 JSON 类型存储在 tasks 表中。

**理由**：
- 简单直接，不需要额外的 tags 表和关联表
- 适合第一阶段的基础需求（只需要显示标签，不需要按标签高效筛选）
- PostgreSQL 的 JSON 类型支持足够好

**替代方案**：
- 方案 A：规范化设计（Tag 表 + TaskTag 关联表）
  - 优点：查询效率高，支持复杂的标签筛选
  - 缺点：增加表数量和查询复杂度，过度设计
  - **拒绝原因**：第一阶段不需要高级标签筛选功能

- 方案 B：不支持标签
  - 优点：最简单
  - 缺点：基础功能不完整
  - **拒绝原因**：标签是任务管理的基础功能

**迁移路径**：如果后续需要高效的标签筛选，可以：
1. 新增 tags 和 task_tags 表
2. 从 JSON 字段迁移数据到新表
3. 在新表上建立索引

### 决策 3：父子任务关系 - 外键约束 + SET NULL

**选择**：parent_id 设置外键约束，删除策略为 SET NULL。

**理由**：
- 数据一致性由数据库保证，防止孤儿任务
- 删除父任务时，子任务不会丢失，parent_id 自动设为 NULL
- 符合用户期望：删除父任务不会影响子任务

**替代方案**：
- 方案 A：不设置外键约束
  - 优点：灵活
  - 缺点：可能产生孤儿任务（parent_id 指向不存在的任务）
  - **拒绝原因**：数据一致性风险高

- 方案 B：删除策略为 CASCADE
  - 优点：自动级联删除，逻辑清晰
  - 缺点：用户误删父任务会导致所有子任务丢失
  - **拒绝原因**：风险太大，用户可能误操作

**实际实现**：虽然外键设为 SET NULL，但在业务层实现级联软删除：
- 用户调用 DELETE API 删除父任务时，service 层主动级联软删除所有子任务
- 这样既保证数据完整性，又符合用户期望

### 决策 4：软删除实现 - 独立字段

**选择**：使用 `is_deleted: bool` 字段，不记录删除时间。

**理由**：
- 简单直接，查询时只需过滤 `is_deleted=false`
- 不需要删除时间，因为第一阶段不支持恢复功能
- 节省存储空间

**替代方案**：
- 方案 A：同时记录 deleted_at 时间戳
  - 优点：可以知道何时删除
  - 缺点：增加字段，第一阶段用不到
  - **拒绝原因**：YAGNI 原则

- 方案 B：使用 status 字段表示删除
  - 优点：不需要额外字段
  - 缺点：混淆业务状态和删除状态
  - **拒绝原因**：职责不清

### 决策 5：索引设计 - 只建单列索引

**选择**：只建立 4 个单列索引（user_id, status, is_deleted, parent_id）。

**理由**：
- 简单，易于维护
- 第一阶段不追求极致性能，优先功能完整性
- 组合索引会增加写入开销，且收益不明确

**替代方案**：
- 方案 A：建立组合索引（如 idx_user_status_deleted）
  - 优点：查询效率更高
  - 缺点：增加写入开销，过度优化
  - **拒绝原因**：第一阶段不需要，等实际使用后根据慢查询日志再优化

**优化路径**：
1. 上线后收集慢查询日志
2. 分析高频查询模式
3. 针对性地添加组合索引

### 决策 6：循环引用检测 - Service 层实现

**选择**：更新 parent_id 时，在 service 层递归检查循环引用。

**理由**：
- 数据库层面难以实现循环检测
- Service 层可以提供更友好的错误信息
- 实现简单，性能开销可接受（任务树层级通常不深）

**算法**：
```python
async def check_circular_reference(task_id: UUID, new_parent_id: UUID) -> bool:
    """检查是否会形成循环引用"""
    current = new_parent_id
    visited = set()
    while current:
        if current == task_id:
            return True  # 检测到循环
        if current in visited:
            break  # 防止无限循环
        visited.add(current)
        parent = await repository.get_by_id(current)
        current = parent.parent_id if parent else None
    return False
```

**性能考虑**：
- 最坏情况：O(n) 时间复杂度，n 为任务树深度
- 实际场景：任务树深度通常 < 10 层，性能可接受
- 如果后续发现性能问题，可以添加缓存

### 决策 7：级联删除实现 - Service 层递归

**选择**：软删除父任务时，service 层递归查找并软删除所有子任务。

**理由**：
- 符合用户预期：删除父任务，子任务也应该删除
- 软删除保证数据不会真正丢失，如有需要可以恢复（虽然第一阶段不提供恢复 API）
- Service 层实现，逻辑清晰，易于测试

**算法**：
```python
async def delete_task_cascade(task_id: UUID) -> None:
    """递归软删除任务及其所有子任务"""
    # 1. 软删除当前任务
    await repository.soft_delete(task_id)

    # 2. 查找所有直接子任务
    children = await repository.get_children(task_id)

    # 3. 递归删除每个子任务
    for child in children:
        await delete_task_cascade(child.id)
```

**风险缓解**：
- 在删除前验证任务所有权（user_id）
- 记录删除操作到审计日志
- 提供详细的删除结果（删除了多少个任务）

### 决策 8：响应格式 - 复用 auth 领域格式

**选择**：完全复用 auth 领域的统一响应格式。

**理由**：
- 保持全局一致性
- 前端不需要适配不同的响应格式
- 减少维护成本

**格式**：
```python
{
  "code": 200,          # HTTP 状态码
  "data": {...},        # 响应数据
  "message": "success"  # 响应消息
}
```

**列表 API 特殊处理**：
```python
{
  "code": 200,
  "data": {
    "tasks": [...],     # 任务列表
    "pagination": {     # 分页信息
      "current_page": 1,
      "page_size": 20,
      "total_count": 100,
      "total_pages": 5
    }
  },
  "message": "success"
}
```

## Risks / Trade-offs

### 风险 1：循环引用检测性能
- **风险**：如果任务树很深（> 100 层），循环检测可能很慢
- **概率**：低（实际场景任务树深度通常 < 10 层）
- **缓解措施**：
  - 在文档中建议任务树深度不超过 20 层
  - 如果发现性能问题，可以添加深度限制或缓存

### 风险 2：级联删除误操作
- **风险**：用户误删父任务，导致大量子任务被删除
- **概率**：中等
- **缓解措施**：
  - API 文档清楚说明级联删除行为
  - 前端添加二次确认对话框
  - 虽然第一阶段不提供恢复 API，但数据在数据库中保留（软删除）

### 风险 3：JSON 字段查询性能
- **风险**：使用 JSON 存储 tags，无法高效按标签筛选
- **概率**：高（后续肯定需要标签筛选）
- **缓解措施**：
  - 第一阶段接受这个限制，优先功能交付
  - 第二阶段实现高级筛选时，可以迁移到规范化设计
  - PostgreSQL 的 GIN 索引可以优化 JSON 查询（如有需要）

### Trade-off 1：简单 vs 性能
- **选择**：优先简单，性能其次
- **理由**：第一阶段重点是快速交付核心功能，等上线后根据实际情况优化
- **影响**：初期可能有性能问题，但通过索引优化可以解决

### Trade-off 2：完整 vs 最小
- **选择**：实现最小可用功能集，不追求完整
- **理由**：YAGNI 原则，避免过度设计
- **影响**：后续需要多次迭代添加功能，但每次迭代都是增量且可控的

## Migration Plan

### 数据库迁移步骤

1. **创建迁移脚本**
   ```bash
   cd /Users/zalelee/Code/tatake_backend
   uv run alembic revision -m "create tasks table"
   ```

2. **编写迁移内容**
   - 创建 tasks 表（15 个字段）
   - 创建 4 个索引
   - 创建外键约束（parent_id → tasks.id, user_id → auth.id）

3. **测试环境验证**
   - 执行迁移：`uv run alembic upgrade head`
   - 验证表结构：检查字段类型、索引、约束
   - 测试数据插入、查询、更新、删除

4. **生产环境部署**
   - 在维护窗口执行迁移
   - 监控迁移过程，确保无错误
   - 验证 API 正常工作

### 回滚方案
- Alembic 支持 `downgrade` 命令回滚迁移
- 回滚脚本会删除 tasks 表
- 如有测试数据，会一并删除（第一阶段可接受）

## Open Questions

### Q1：是否需要任务排序功能？
- **问题**：用户是否需要自定义任务顺序（如拖拽排序）？
- **当前决策**：第一阶段不支持，默认按创建时间倒序
- **后续决策**：如果需要，添加 `order` 字段（整数），支持手动排序

### Q2：是否需要任务归档功能？
- **问题**：已完成的任务是否需要归档（archive），与软删除不同？
- **当前决策**：第一阶段不区分归档和删除，都使用软删除
- **后续决策**：如果需要，添加 `is_archived` 字段

### Q3：是否需要任务权限控制？
- **问题**：任务是否支持多人协作（分享、权限管理）？
- **当前决策**：第一阶段只支持个人任务，不支持协作
- **后续决策**：如果需要，添加 task_permissions 表

## 总结

本设计遵循以下核心原则：
1. **KISS（保持简单）**：避免过度设计，优先最简单的解决方案
2. **YAGNI（你不会需要它）**：不预留暂不需要的字段和功能
3. **DRY（不要重复）**：复用 auth 领域的响应格式和架构模式
4. **可测试性**：所有业务逻辑都在 service 层，易于编写单元测试
5. **可扩展性**：预留清晰的扩展路径，后续迭代成本可控

预期的实施时间：3-5 天（包含测试和文档）。
