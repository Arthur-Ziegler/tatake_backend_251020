# TaKeKe 数据层接口使用手册

## 📖 文档说明

本文档是 TaKeKe 项目数据层的完整接口使用指南，面向所有服务层开发者。通过本手册，您可以：
- 无需阅读数据层源码，直接使用所有数据接口
- 了解每个接口的参数、返回值和使用示例
- 掌握异常处理和最佳实践
- 安全、高效地进行数据操作

## 🏗️ 数据层架构概览

### 层次结构
```
服务层 (Service Layer)
    ↓ 调用
数据访问层 (Repository Layer)
    ↓ 操作
数据模型层 (Model Layer)
    ↓ 存储
数据库 (Database)
```

### 核心组件
- **模型层**: 定义数据结构和业务规则
- **Repository层**: 提供数据访问接口，封装业务逻辑
- **异常处理**: 统一的错误处理机制

## 🔧 快速开始

### 1. 导入所需模块

```python
# 导入Repository类
from src.repositories import (
    UserRepository,
    TaskRepository,
    FocusRepository,
    RewardRepository
)

# 导入模型和枚举
from src.models import (
    User, Task, FocusSession, Reward,
    TaskStatus, PriorityLevel, SessionType,
    RewardType, TransactionType
)

# 导入异常类
from src.repositories.base import (
    RepositoryError,
    RepositoryValidationError,
    RepositoryNotFoundError
)
```

### 2. 获取数据库会话

```python
from src.database.connection import DatabaseConnection

# 获取数据库连接
db_connection = DatabaseConnection()

# 使用上下文管理器确保会话正确关闭
with db_connection.get_session() as session:
    # 在这里使用Repository
    pass
```

### 3. 创建Repository实例

```python
with db_connection.get_session() as session:
    user_repo = UserRepository(session)
    task_repo = TaskRepository(session)
    focus_repo = FocusRepository(session)
    reward_repo = RewardRepository(session)

    # 开始使用数据接口
    # ...
```

## 👤 用户系统接口

### UserRepository - 用户数据访问

#### 创建用户

```python
# 创建注册用户
user_data = {
    "email": "user@example.com",
    "nickname": "张三",
    "password_hash": "hashed_password_here",
    "user_type": "registered"  # 或 "guest"
}

user = user_repo.create(user_data)
print(f"用户创建成功: {user.id}")
```

#### 查询用户

```python
# 根据邮箱查询用户（用户邮箱必须唯一）
try:
    user = user_repo.find_by_email("user@example.com")
    print(f"找到用户: {user.nickname}")
except RepositoryNotFoundError:
    print("用户不存在")

# 根据手机号查询用户
user = user_repo.find_by_phone("13800138000")

# 根据微信OpenID查询用户
user = user_repo.find_by_wechat_openid("wx_openid_123")

# 查询所有注册用户
registered_users = user_repo.find_registered_users(is_active=True)

# 查询所有游客用户
guest_users = user_repo.find_guest_users()

# 查询活跃用户
active_users = user_repo.find_active_users()
```

#### 用户验证

```python
# 检查邮箱是否已存在
if user_repo.email_exists("new@example.com"):
    print("邮箱已被使用")

# 检查手机号是否已存在
if user_repo.phone_exists("13900139000"):
    print("手机号已被使用")
```

#### 用户管理

```python
# 创建游客用户
guest_user = user_repo.create_guest_user(nickname="临时用户")

# 升级游客为注册用户
updated_user = user_repo.upgrade_guest_to_registered(
    user_id=guest_user.id,
    email="registered@example.com",
    password_hash="new_hashed_password",
    nickname="正式用户"
)
```

#### 基础CRUD操作

```python
# 根据ID查询用户
user = user_repo.get_by_id("user_id_here")

# 更新用户信息
updated_user = user_repo.update(
    user_id,
    {"nickname": "新昵称", "is_active": True}
)

# 删除用户（软删除）
success = user_repo.delete(user_id)

# 检查用户是否存在
exists = user_repo.exists(email="user@example.com")

# 统计用户数量
count = user_repo.count(user_type="registered")
```

## 📋 任务系统接口

### TaskRepository - 任务数据访问

#### 创建任务

```python
# 创建基础任务
task_data = {
    "user_id": "user_id_here",
    "title": "完成项目文档",
    "description": "编写项目的技术文档和用户手册",
    "status": TaskStatus.PENDING,
    "priority": PriorityLevel.HIGH
}

task = task_repo.create(task_data)

# 创建子任务
subtask_data = {
    "user_id": "user_id_here",
    "title": "编写API文档",
    "parent_id": task.id,  # 指定父任务
    "status": TaskStatus.PENDING
}

subtask = task_repo.create(subtask_data)
```

#### 查询任务

```python
# 根据状态查询任务
pending_tasks = task_repo.find_by_status(TaskStatus.PENDING, user_id="user_id")
completed_tasks = task_repo.find_by_status(TaskStatus.COMPLETED)

# 根据优先级查询任务
high_priority_tasks = task_repo.find_by_priority(PriorityLevel.HIGH)

# 查询即将到期的任务（7天内）
due_tasks = task_repo.find_due_tasks(days=7)

# 查询过期任务
overdue_tasks = task_repo.find_overdue_tasks()

# 查询根任务（没有父任务的任务）
root_tasks = task_repo.get_root_tasks(user_id="user_id")

# 查询子任务
subtasks = task_repo.get_subtasks(parent_id="parent_task_id")
```

#### 任务管理

```python
# 完成任务
completed_task = task_repo.complete_task("task_id_here")

# 归档任务
archived_task = task_repo.archive_task("task_id_here")

# 恢复已归档的任务
restored_task = task_repo.restore_task("task_id_here")
```

#### 任务层次结构

```python
# 获取任务的完整层次结构
hierarchy = task_repo.get_task_hierarchy("task_id_here")
print(f"任务: {hierarchy['task']['title']}")
print(f"子任务数量: {len(hierarchy['subtasks'])}")

for subtask in hierarchy['subtasks']:
    print(f"- {subtask['title']}")
```

#### 每日TOP3任务

```python
# 获取用户今日TOP3任务
daily_top3 = task_repo.get_daily_top3("user_id_here")
for i, task_top3 in enumerate(daily_top3, 1):
    print(f"第{i}位: {task_top3.task.title}")

# 设置每日TOP3任务
task_ids = ["task1_id", "task2_id", "task3_id"]
top3_tasks = task_repo.set_daily_top3("user_id_here", task_ids)
```

#### 基础CRUD操作

```python
# 根据ID查询任务
task = task_repo.get_by_id("task_id_here")

# 更新任务
updated_task = task_repo.update(
    "task_id_here",
    {"title": "新标题", "status": TaskStatus.IN_PROGRESS}
)

# 删除任务
success = task_repo.delete("task_id_here")
```

## 🎯 专注系统接口

### FocusRepository - 专注会话数据访问

#### 开始专注会话

```python
# 开始基础专注会话
focus_session = focus_repo.start_focus_session(
    user_id="user_id_here",
    duration_minutes=25,  # 专注时长（分钟）
    task_id="task_id_here"  # 可选：关联的任务
)

print(f"专注会话已开始: {focus_session.id}")
print(f"预计结束时间: {focus_session.started_at + timedelta(minutes=25)}")
```

#### 查询专注会话

```python
# 查询用户所有专注会话
user_sessions = focus_repo.find_by_user("user_id_here")

# 查询正在进行的专注会话
active_sessions = focus_repo.find_active_sessions("user_id_here")

# 查询已完成的专注会话
completed_sessions = focus_repo.find_completed_sessions("user_id_here")

# 查询用户今日专注会话
today_sessions = focus_repo.find_user_today_sessions("user_id_here")

# 根据会话类型查询
focus_sessions = focus_repo.find_by_session_type(SessionType.FOCUS)
break_sessions = focus_repo.find_by_session_type(SessionType.BREAK)
```

#### 专注会话管理

```python
# 完成专注会话
completed_session = focus_repo.complete_session("session_id_here")
print(f"专注时长: {completed_session.duration_minutes}分钟")

# 暂停专注会话
paused_session = focus_repo.pause_session("session_id_here")

# 恢复专注会话
resumed_session = focus_repo.resume_session("session_id_here")

# 取消专注会话
cancelled_session = focus_repo.cancel_session("session_id_here")
```

#### 专注统计数据

```python
# 获取用户专注统计
stats = focus_repo.get_user_focus_statistics("user_id_here")
print(f"总专注时长: {stats['total_focus_minutes']}分钟")
print(f"完成会话数: {stats['completed_sessions']}")
print(f"完成率: {stats['completion_rate']:.2%}")

# 获取每日专注汇总（最近7天）
daily_summary = focus_repo.get_daily_focus_summary("user_id_here", days=7)
for day_data in daily_summary:
    print(f"{day_data['date']}: {day_data['total_minutes']}分钟")

# 获取每周专注汇总
weekly_summary = focus_repo.get_weekly_focus_summary("user_id_here", weeks=4)

# 获取每月专注汇总
monthly_summary = focus_repo.get_monthly_focus_summary("user_id_here", months=12)
```

#### 专注模板管理

```python
# 创建专注模板
template = focus_repo.create_template(
    user_id="user_id_here",
    name="番茄工作法",
    focus_duration=25,  # 专注时长
    break_duration=5,   # 休息时长
    description="25分钟专注，5分钟休息的工作模式"
)

# 应用专注模板
focus_session = focus_repo.apply_template(
    template_id="template_id_here",
    user_id="user_id_here"
)

# 查询用户的所有模板
user_templates = focus_repo.find_user_templates("user_id_here")
```

#### 休息记录管理

```python
# 添加休息记录
break_record = focus_repo.add_break(
    session_id="focus_session_id_here",
    break_duration_minutes=5
)

# 完成休息
completed_break = focus_repo.complete_break("break_id_here")

# 查询会话的所有休息记录
session_breaks = focus_repo.find_session_breaks("focus_session_id_here")
```

## 🏆 奖励系统接口

### RewardRepository - 奖励数据访问

#### 查询奖励

```python
# 查询所有可用奖励
available_rewards = reward_repo.find_available_rewards()

# 根据奖励类型查询
badge_rewards = reward_repo.find_by_reward_type(RewardType.BADGE)
item_rewards = reward_repo.find_by_reward_type(RewardType.ITEM)

# 根据状态查询
active_rewards = reward_repo.find_by_status(is_active=True)
inactive_rewards = reward_repo.find_by_status(is_active=False)

# 根据价格范围查询
affordable_rewards = reward_repo.find_rewards_by_price_range(0, 100)
```

#### 奖励兑换

```python
# 验证用户余额是否足够
can_redeem = reward_repo.validate_user_balance(
    user_id="user_id_here",
    required_fragments=50
)

if can_redeem:
    # 兑换奖励
    transaction = reward_repo.redeem_reward(
        user_id="user_id_here",
        reward_id="reward_id_here"
    )
    print(f"兑换成功，交易ID: {transaction.id}")
else:
    print("碎片余额不足")

# 查询用户已兑换的奖励
redeemed_rewards = reward_repo.get_user_redeemed_rewards("user_id_here")
```

#### 碎片管理

```python
# 获取用户碎片余额
balance = reward_repo.get_user_fragment_balance("user_id_here")
print(f"当前碎片余额: {balance}")

# 奖励碎片
transaction = reward_repo.award_fragments(
    user_id="user_id_here",
    amount=10,  # 碎片数量
    reason="完成专注会话奖励"
)
print(f"奖励成功，当前余额: {transaction.balance_after}")

# 查询用户碎片交易历史
transactions = reward_repo.get_user_transaction_history("user_id_here")
for tx in transactions:
    print(f"{tx.created_at}: {tx.points_change}碎片 - {tx.description}")
```

#### 抽奖系统

```python
# 参与抽奖
lottery_record = reward_repo.draw_lottery(
    user_id="user_id_here",
    cost_fragments=20  # 消耗20碎片
)

if lottery_record.won:
    print(f"恭喜中奖！获得: {lottery_record.reward_name}")
else:
    print("未中奖，下次再来")

# 查询用户抽奖记录
user_lotteries = reward_repo.get_user_lottery_records("user_id_here")

# 获取抽奖统计
lottery_stats = reward_repo.get_lottery_statistics()
print(f"总抽奖次数: {lottery_stats['total_draws']}")
print(f"中奖率: {lottery_stats['win_rate']:.2%}")
```

#### 积分流水

```python
# 创建积分交易记录
transaction = reward_repo.create_points_transaction(
    user_id="user_id_here",
    transaction_type=TransactionType.EARN,  # 或 SPEND
    points_change=50,
    balance_before=100,
    balance_after=150,
    description="完成任务奖励"
)

# 查询用户积分历史
points_history = reward_repo.get_user_points_history("user_id_here")

# 获取用户积分统计汇总
summary = reward_repo.get_user_points_summary("user_id_here", days=30)
print(f"总收入: {summary['total_earned']}碎片")
print(f"总支出: {summary['total_spent']}碎片")
print(f"当前余额: {summary['current_balance']}碎片")
print(f"净变化: {summary['net_change']}碎片")
```

## ⚠️ 异常处理

### 异常类型

```python
from src.repositories.base import (
    RepositoryError,           # 基础异常类
    RepositoryValidationError,  # 参数验证异常
    RepositoryNotFoundError,   # 资源未找到异常
    RepositoryIntegrityError   # 数据完整性异常
)
```

### 异常处理最佳实践

```python
def create_user_safely(user_data):
    try:
        with db_connection.get_session() as session:
            user_repo = UserRepository(session)

            # 检查邮箱是否已存在
            if user_repo.email_exists(user_data["email"]):
                raise ValueError("邮箱已被使用")

            # 创建用户
            user = user_repo.create(user_data)
            return user

    except RepositoryValidationError as e:
        print(f"参数验证失败: {e}")
        return None

    except RepositoryIntegrityError as e:
        print(f"数据完整性冲突: {e}")
        return None

    except RepositoryError as e:
        print(f"数据库操作失败: {e}")
        return None

    except Exception as e:
        print(f"未知错误: {e}")
        return None

# 使用示例
user = create_user_safely({
    "email": "new@example.com",
    "nickname": "新用户",
    "password_hash": "hashed_password"
})
```

### 常见错误场景

```python
# 1. 查找不存在的资源
try:
    user = user_repo.get_by_id("non_existent_id")
    if user is None:
        print("用户不存在")
except RepositoryNotFoundError:
    print("用户不存在")

# 2. 参数验证
try:
    # 无效的邮箱格式
    user = user_repo.create({"email": "", "nickname": "测试"})
except RepositoryValidationError as e:
    print(f"验证错误: {e}")

# 3. 数据完整性约束
try:
    # 重复的邮箱
    user1 = user_repo.create({"email": "same@example.com", "nickname": "用户1"})
    user2 = user_repo.create({"email": "same@example.com", "nickname": "用户2"})
except RepositoryIntegrityError as e:
    print(f"完整性错误: {e}")
```

## 📊 性能优化建议

### 查询优化

```python
# ✅ 推荐：使用具体的查询方法
active_users = user_repo.find_active_users()

# ❌ 避免：获取所有数据后在内存中过滤
all_users = user_repo.get_all()
active_users = [u for u in all_users if u.is_active]

# ✅ 推荐：使用索引字段查询
user = user_repo.find_by_email("user@example.com")

# ❌ 避免：使用非索引字段进行大量查询
```

### 批量操作

```python
# ✅ 推荐：在单个会话中进行多个操作
with db_connection.get_session() as session:
    user_repo = UserRepository(session)
    task_repo = TaskRepository(session)

    # 创建用户
    user = user_repo.create(user_data)

    # 为用户创建多个任务
    for task_data in task_list:
        task_data["user_id"] = user.id
        task_repo.create(task_data)

    # 自动提交所有更改

# ❌ 避免：多个独立的会话
# user_repo = UserRepository(session1)
# task_repo = TaskRepository(session2)  # 不同的会话
```

### 分页查询

```python
# 对于大量数据，考虑在Repository中添加分页支持
# 目前可以结合skip和limit实现类似效果
def get_users_paginated(page: int, size: int):
    with db_connection.get_session() as session:
        user_repo = UserRepository(session)

        # 获取总数
        total = user_repo.count()

        # 简单分页（实际项目中建议添加专门的分页方法）
        all_users = user_repo.get_all()
        start = (page - 1) * size
        end = start + size

        return {
            "users": all_users[start:end],
            "total": total,
            "page": page,
            "size": size
        }
```

## 🔒 安全注意事项

### 输入验证

```python
# ✅ 始终验证用户输入
def create_user_safe(email: str, nickname: str):
    # 验证邮箱格式
    if not "@" in email or len(email) > 255:
        raise ValueError("无效的邮箱格式")

    # 验证昵称长度
    if not nickname or len(nickname) > 100:
        raise ValueError("昵称不能为空且不超过100个字符")

    # 创建用户
    return user_repo.create({
        "email": email,
        "nickname": nickname,
        "user_type": "registered"
    })
```

### 密码处理

```python
# ✅ 使用密码哈希
import bcrypt

def hash_password(password: str) -> str:
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')

# 创建用户时存储哈希密码
user_data = {
    "email": "user@example.com",
    "nickname": "用户",
    "password_hash": hash_password("plain_password")  # 存储哈希值
}
```

### 权限检查

```python
# ✅ 在业务层添加权限检查
def update_user_profile(current_user_id: str, target_user_id: str, updates: dict):
    # 检查是否有权限修改目标用户
    if current_user_id != target_user_id:
        raise PermissionError("无权限修改其他用户信息")

    with db_connection.get_session() as session:
        user_repo = UserRepository(session)
        return user_repo.update(target_user_id, updates)
```

## 🧪 测试支持

### 测试数据准备

```python
# 测试时使用内存数据库
import pytest
from sqlmodel import create_engine
from sqlalchemy.orm import sessionmaker

@pytest.fixture
def test_session():
    engine = create_engine("sqlite:///:memory:")
    from src.models.base_model import BaseSQLModel
    BaseSQLModel.metadata.create_all(engine)

    SessionLocal = sessionmaker(bind=engine)
    session = SessionLocal()

    try:
        yield session
    finally:
        session.close()

# 测试示例
def test_create_user(test_session):
    user_repo = UserRepository(test_session)
    user = user_repo.create({
        "email": "test@example.com",
        "nickname": "测试用户",
        "user_type": "guest"
    })

    assert user.id is not None
    assert user.email == "test@example.com"
```

## 📝 最佳实践总结

### DO - 推荐做法

1. **使用上下文管理器**确保数据库会话正确关闭
2. **具体的查询方法**而不是获取所有数据后在内存中过滤
3. **异常处理**包装所有数据访问操作
4. **参数验证**在调用Repository之前验证输入
5. **事务管理**在单个会话中完成相关的多个操作

### DON'T - 避免做法

1. **不要**在循环中创建多个数据库会话
2. **不要**忽略Repository抛出的异常
3. **不要**在业务层直接操作SQL
4. **不要**假设数据库操作总是成功
5. **不要**忘记关闭数据库会话

### 代码示例

```python
# ✅ 完整的最佳实践示例
def complete_user_task(user_id: str, task_id: str):
    """
    完成用户任务的最佳实践示例
    """
    try:
        with db_connection.get_session() as session:
            # 创建Repository实例
            user_repo = UserRepository(session)
            task_repo = TaskRepository(session)
            focus_repo = FocusRepository(session)
            reward_repo = RewardRepository(session)

            # 1. 验证用户存在
            user = user_repo.get_by_id(user_id)
            if not user:
                raise ValueError("用户不存在")

            # 2. 验证任务存在且属于该用户
            task = task_repo.get_by_id(task_id)
            if not task or task.user_id != user_id:
                raise ValueError("任务不存在或无权限访问")

            # 3. 完成任务
            completed_task = task_repo.complete_task(task_id)

            # 4. 如果有相关专注会话，也完成它
            active_sessions = focus_repo.find_active_sessions(user_id)
            for session in active_sessions:
                if session.task_id == task_id:
                    focus_repo.complete_session(session.id)
                    break

            # 5. 奖励碎片（根据任务复杂度）
            fragment_reward = 10 if completed_task.priority == PriorityLevel.HIGH else 5
            reward_repo.award_fragments(
                user_id=user_id,
                amount=fragment_reward,
                reason=f"完成任务: {completed_task.title}"
            )

            return {
                "task": completed_task,
                "fragments_awarded": fragment_reward
            }

    except RepositoryValidationError as e:
        print(f"参数验证失败: {e}")
        raise

    except RepositoryNotFoundError as e:
        print(f"资源未找到: {e}")
        raise

    except RepositoryError as e:
        print(f"数据库操作失败: {e}")
        raise

    except Exception as e:
        print(f"未知错误: {e}")
        raise
```

## 📞 技术支持

如果您在使用数据层接口时遇到问题，请：

1. **查看异常信息**：大多数错误都有详细的错误描述
2. **检查参数**：确保传递给Repository的参数格式正确
3. **参考示例**：本文档提供了每个接口的完整使用示例
4. **查看测试**：`tests/repositories/` 目录有更多使用示例

## 🚀 下一步

数据层接口已经完全准备好供服务层使用。您可以：

1. 开始实现业务逻辑服务层
2. 创建API接口层
3. 添加缓存层（如果需要）
4. 实现更复杂的业务流程

---

**文档版本**: 1.0
**最后更新**: 2025年10月
**维护者**: TaKeKe 开发团队