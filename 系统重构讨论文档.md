# TaKeKe 系统重构讨论文档

## 一、已确认的架构决策

### 1.1 Auth 领域
- ✅ 只返回 user_id，不联合查询 user 表
- ✅ 存储：密码哈希、验证码等认证相关数据
- ✅ 其他领域通过 token 解析获取 user_id（无需中间件）

### 1.2 User 领域
- ✅ 存储：用户画像（昵称、头像、生日等）、用户设置、积分余额
- ✅ 不存储统计数据（统计数据在 Analytics）
- ✅ Auth 注册后，**同步直接调用** User 领域创建记录（不用领域事件）

### 1.3 Task 领域
- ✅ 状态流转：待办 ↔ 进行中 ↔ 已完成 ↔ 待办（可循环）
- ✅ 暂停：独立状态（暂时不做）
- ✅ 删除：软删除
- ✅ **不记录实际执行时间**（这个职责在 Focus 领域）

### 1.4 Chat 领域
- ✅ 完全独立，不与其他数据库交互
- ✅ 需要独立的 SQLite 数据库存储聊天记录
- ✅ 技术栈：LangGraph + OpenAI（配置在 .env）

### 1.5 实施原则
- ✅ 每个小任务可独立验证
- ✅ 每个小任务可直接并入 FastAPI 测试
- ✅ 不引入过度复杂的设计（如领域事件、中间件等）

---

## 二、核心疑问与讨论

### 🔴 疑问 A：数据库架构设计（最关键）

你提到："任务、专注、奖励、积分之间有很多关系，是不是放到一个数据库的不同表里比较方便？"

这个问题非常关键，直接影响领域划分和代码组织。我需要跟你讨论几个方案：

#### 方案 1：单数据库多领域表（推荐）
```
tatake.db (SQLite)
  ├── auth_users          # Auth 领域
  ├── auth_tokens
  ├── auth_verification_codes
  ├── users               # User 领域
  ├── user_settings
  ├── tasks               # Task 领域
  ├── focus_sessions      # Focus 领域
  ├── rewards             # Reward 领域
  ├── reward_transactions
  └── analytics_summary   # Analytics 领域（可能是视图或缓存表）

chat.db (SQLite，独立)
  ├── conversations
  └── messages
```

**优点：**
- 可以使用外键约束（如 `tasks.user_id` → `users.id`）
- 可以用数据库事务保证一致性（如任务完成 + 积分增加）
- 查询方便（JOIN 查询）

**缺点：**
- 领域边界在代码层面，数据库层面耦合
- 跨领域修改表结构时影响范围大

---

#### 方案 2：多数据库严格隔离（不推荐）
```
auth.db
  ├── auth_users
  └── ...

user.db
  ├── users
  └── ...

task.db
  ├── tasks
  └── ...

...
```

**优点：**
- 领域完全隔离，符合 DDD 理论
- 未来可以拆分微服务

**缺点：**
- SQLite 不支持跨数据库事务（需要手动实现补偿逻辑）
- 无法使用外键约束
- 查询复杂（需要应用层 JOIN）
- **对你的场景来说过度设计**

---

#### 我的建议：方案 1（单数据库多领域表）

理由：
1. 你明确说了"不考虑微服务，保持系统简洁"
2. SQLite 本身就是单文件数据库，强行拆分反而增加复杂度
3. 任务、专注、积分之间的事务一致性很重要（如任务完成必须加积分）

**但代码层面仍然严格按 DDD 划分：**
- 每个领域有独立的 Repository（只操作自己的表）
- 跨领域调用通过 Service 层，而不是直接跨表查询
- 例如：`TaskService.complete_task()` 内部调用 `RewardService.add_points()`

**你同意这个方案吗？还是有其他想法？**

---

### 🟡 疑问 B：Task、Focus、Reward 的交互流程

你说这几个领域有很多联动，我需要明确具体的业务流程：

#### 场景 1：用户完成任务
```
用户点击"完成任务"
  ↓
1. Task 领域：更新任务状态为"已完成"
2. Reward 领域：给用户增加积分（根据任务难度？固定值？）
3. Analytics 领域：更新用户统计数据（总完成任务数 +1）
```

**问题 B.1：积分计算规则是什么？**
- 固定积分（如每个任务 +10 分）？
- 根据任务属性（如优先级、预计时长）动态计算？
- 是否需要额外的"积分规则引擎"？

**问题 B.2：这个流程的事务边界是什么？**
- 方案 A：任务完成、积分增加 在同一个数据库事务中（强一致性）
- 方案 B：任务完成后，异步触发积分增加（最终一致性）
- **你倾向于哪个？** 我建议方案 A，因为系统简单，用户少。

---

#### 场景 2：用户使用番茄钟专注
```
用户选择一个任务，开始番茄钟
  ↓
1. Focus 领域：创建一个 focus_session 记录（task_id, start_time）
2. 用户完成 25 分钟后，结束番茄钟
3. Focus 领域：更新 focus_session（end_time, duration=25min）
4. Task 领域：累加任务的"实际执行时间"？？
5. Reward 领域：给用户增加积分（专注奖励）？？
```

**问题 B.3：番茄钟与任务的关系是怎样的？**
- 番茄钟必须关联任务吗？还是可以独立存在（如"自由专注"）？
- 番茄钟结束后，是否自动更新任务的执行时间？
- 如果用户中途放弃番茄钟（如只专注了 10 分钟），是否记录？是否给积分？

**问题 B.4：专注积分的规则是什么？**
- 每完成一个番茄钟给固定积分（如 +5 分）？
- 还是按实际专注时长计算（如每分钟 +1 分）？
- 是否需要防止刷分（如连续开启番茄钟但不真正专注）？

---

#### 场景 3：用户兑换奖励
```
用户用 100 积分兑换一个奖励
  ↓
1. Reward 领域：扣除用户 100 积分
2. Reward 领域：创建一个兑换记录
3. User 领域：更新用户积分余额？？
```

**问题 B.5：积分余额存在哪里？**
- 你之前说"余额存在 User 表"，但 Reward 领域如何更新 User 表？
- 方案 A：User 表只是缓存，实际余额通过 `SUM(reward_transactions)` 计算
- 方案 B：User 表是权威数据源，Reward 调用 User 领域的接口更新
- **你倾向于哪个？**

**问题 B.6：兑换的奖励是虚拟的还是实体的？**
- 如果是虚拟奖励（如"解锁主题"），如何存储用户已拥有的奖励？
- 如果是实体奖励（如"咖啡券"），是否需要发放/核销流程？

---

### 🟢 疑问 C：Analytics 领域的实现方式

你说"统计数据在 Analytics 表"，我需要明确这是什么样的表。

#### 方案 1：实时计算（无独立表）
```python
# Analytics 领域没有自己的表，只有查询逻辑
class AnalyticsService:
    def get_user_stats(self, user_id):
        total_tasks = task_repo.count_by_user(user_id)
        total_focus_time = focus_repo.sum_duration_by_user(user_id)
        total_points = reward_repo.sum_points_by_user(user_id)
        return {"total_tasks": total_tasks, ...}
```

**优点：**数据永远是最新的
**缺点：**每次查询都要跨表统计，性能可能差（但 SQLite + 少量用户应该没问题）

---

#### 方案 2：定时汇总（有独立表）
```sql
CREATE TABLE analytics_user_summary (
    user_id INTEGER PRIMARY KEY,
    total_tasks INTEGER,
    total_focus_time INTEGER,
    total_points INTEGER,
    updated_at TIMESTAMP
);
```

定时任务（如每小时）或事件触发（如任务完成时）更新这个表。

**优点：**查询快
**缺点：**数据有延迟，需要维护定时任务

---

**问题 C.1：你倾向于哪个方案？**
我建议先用**方案 1**（实时计算），如果后期性能有问题再优化成方案 2。

**问题 C.2：统计维度有哪些？**
从文档看，可能需要：
- 用户维度：总任务数、总专注时长、总积分、今日完成任务数、本周数据等
- 任务维度：每个任务的总专注时长、完成次数等
- 时间维度：按天/周/月聚合

需要我整理一个完整的统计需求清单吗？

---

## 三、分阶段实施计划（草案）

基于你的要求（每个阶段可独立验证和测试），我初步规划如下阶段：

### 阶段 0：基础设施（Foundation）
**目标：** 搭建项目骨架，让后续领域可以快速开发

**任务：**
1. 数据库连接配置（SQLAlchemy + SQLite）
2. 依赖注入框架（如果需要的话，或者简单的工厂模式）
3. 统一的响应格式、异常处理
4. FastAPI 基础路由结构
5. 测试框架配置（pytest + fixtures）

**验收标准：**
- 可以启动 FastAPI 服务
- 可以连接数据库并创建表
- 可以运行一个简单的测试用例

**是否需要这个阶段？** 还是直接从 User 领域开始，边做边搭基础设施？

---

### 阶段 1：User 领域（基于已完成的 Auth）
**目标：** 用户管理功能，确保 Auth → User 的流程跑通

**任务：**
1. 设计 User 领域的数据模型（users 表、user_settings 表）
2. 实现 UserRepository（CRUD）
3. 实现 UserService（业务逻辑）
4. 实现 User API 路由（获取用户信息、更新画像、修改设置等）
5. **关键：** 修改 Auth 领域的注册逻辑，注册成功后调用 UserService 创建用户记录
6. 编写集成测试（注册 → 查询用户信息）

**验收标准：**
- 可以通过 API 注册用户，并自动创建 User 记录
- 可以查询和更新用户信息
- 所有 API 都有测试覆盖

**预估工作量：** ？（你觉得需要多久）

---

### 阶段 2：Task 领域核心（不含积分、不含专注）
**目标：** 任务的增删改查、状态管理

**任务：**
1. 设计 Task 数据模型（tasks 表）
2. 实现 TaskRepository
3. 实现 TaskService（创建、更新、删除、状态流转逻辑）
4. 实现 Task API 路由
5. 编写测试（状态机测试、软删除测试等）

**验收标准：**
- 可以创建、查询、更新、删除任务
- 可以正确流转任务状态（待办 ↔ 进行中 ↔ 已完成）
- 软删除生效

**预估工作量：** ？

---

### 阶段 3：Chat 领域（完全独立）
**目标：** AI 聊天功能，独立验证

**任务：**
1. 设计 Chat 数据模型（chat.db：conversations 表、messages 表）
2. 实现 LangGraph 集成（对接 OpenAI）
3. 实现 ChatService（创建对话、发送消息、获取历史）
4. 实现 Chat API 路由
5. 编写测试（mock OpenAI 响应）

**验收标准：**
- 可以创建对话并发送消息
- 可以查询历史对话
- OpenAI 集成正常

**预估工作量：** ？

---

### 阶段 4：Reward 领域（积分系统）
**目标：** 积分的增减、查询、兑换

**任务：**
1. 设计 Reward 数据模型（rewards 表、reward_transactions 表）
2. 实现 RewardRepository
3. 实现 RewardService（增加积分、扣除积分、兑换奖励）
4. 实现 Reward API 路由
5. **关键：** 确定积分余额的存储方式（User 表 vs 实时计算）
6. 编写测试

**验收标准：**
- 可以手动给用户加/减积分（测试接口）
- 可以查询用户积分余额
- 可以兑换奖励

**问题：这个阶段是否需要与 Task 集成（任务完成自动加分）？** 还是先独立验证积分功能？

---

### 阶段 5：Focus 领域（番茄钟）
**目标：** 专注模式，记录专注时长

**任务：**
1. 设计 Focus 数据模型（focus_sessions 表）
2. 实现 FocusRepository
3. 实现 FocusService（开始/结束专注、查询专注历史）
4. 实现 Focus API 路由
5. 编写测试

**验收标准：**
- 可以开始/结束番茄钟
- 可以查询用户的专注历史
- 可以关联任务（如果需要的话）

**问题：这个阶段是否需要与 Task、Reward 集成？** 还是先独立验证？

---

### 阶段 6：领域集成（Task + Reward + Focus）
**目标：** 打通任务完成 → 积分奖励、专注 → 积分奖励的流程

**任务：**
1. 在 TaskService.complete_task() 中调用 RewardService.add_points()
2. 在 FocusService.end_session() 中调用 RewardService.add_points()
3. 实现积分规则引擎（如果需要的话）
4. 编写集成测试（完成任务 → 检查积分增加）

**验收标准：**
- 完成任务后，积分自动增加
- 完成番茄钟后，积分自动增加
- 事务一致性（任务完成和积分增加要么都成功，要么都失败）

---

### 阶段 7：Analytics 领域（统计分析）
**目标：** 提供各种统计数据

**任务：**
1. 实现 AnalyticsService（查询用户统计、任务统计、时间维度统计）
2. 实现 Analytics API 路由
3. 编写测试

**验收标准：**
- 可以查询用户的各种统计数据
- 数据准确（与实际任务、专注、积分记录一致）

---

## 四、需要你回答的问题汇总

### 优先级最高（直接影响架构）：
1. **疑问 A：** 数据库方案，你同意"单数据库多领域表"吗？
2. **疑问 B.2：** 任务完成 + 积分增加，是同一个事务（强一致性）还是异步（最终一致性）？
3. **疑问 B.5：** 积分余额存储方式，User 表缓存 vs 实时计算？

### 优先级中等（影响功能实现）：
4. **疑问 B.1：** 积分计算规则是什么？（固定值？动态计算？）
5. **疑问 B.3：** 番茄钟必须关联任务吗？中途放弃如何处理？
6. **疑问 B.4：** 专注积分规则是什么？
7. **疑问 B.6：** 奖励是虚拟的还是实体的？如何存储用户已拥有的奖励？
8. **疑问 C.1：** Analytics 用实时计算还是定时汇总？

### 优先级较低（影响实施细节）：
9. 是否需要"阶段 0：基础设施"？还是直接从 User 开始？
10. 阶段 4（Reward）是否需要立即与 Task 集成，还是先独立验证？
11. 阶段 5（Focus）是否需要立即集成，还是先独立验证？
12. 每个阶段的预估工作量（你希望每个阶段多长时间完成）？

---

## 五、下一步

请你逐一回答上述问题（可以分优先级回答，不重要的可以让我自己决定）。

回答完后，我会：
1. 绘制最终的架构图（领域模型、数据库 ER 图、依赖关系图）
2. 细化分阶段计划（每个阶段的详细任务清单、数据模型定义、API 定义）
3. 开始第一阶段的实施

如果有任何疑问或不同意见，请直接指出！
